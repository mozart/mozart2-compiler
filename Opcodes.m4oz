dnl
dnl Authors:
dnl   Ralf Scheidhauer <scheidhr@ps.uni-sb.de>
dnl   Leif Kornstaedt <kornstae@ps.uni-sb.de>
dnl
dnl Copyright:
dnl   Ralf Scheidhauer and Leif Kornstaedt, 1997
dnl
dnl Last change:
dnl   $Date$ by $Author$
dnl   $Revision$
dnl
dnl This file is part of Mozart, an implementation of Oz 3:
dnl    $MOZARTURL$
dnl
dnl See the file "LICENSE" or
dnl    $LICENSEURL$
dnl for information on usage and redistribution
dnl of this file, and for a DISCLAIMER OF ALL
dnl WARRANTIES.
dnl

define(instruction,
	`ifelse(numOfRegs($2,$3,$4),1,oneReg($@),
		numOfRegs($2,$3,$4),2,twoRegs($@),
		noReg($@))')
define(instructionsUnneededForNewCompiler,`divert(-1)')
define(readArg,$1)
define(writeArg,$1)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% InstructionSizes maps instr labels to integers
%%

define(noReg,'$1': {GetInstructionSize '$1'})
define(oneReg,'$1': {GetInstructionSize '$1X'})
define(twoRegs,'$1': {GetInstructionSize '$1XX'})

InstructionSizes =
instructionSizes(include(OZINCDIR/instrDefs.m4))

undefine(`noReg')
undefine(`oneReg')
undefine(`twoRegs')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Opcodes maps instructions with implicit addressing modes to integers
%%

define(noReg,
'$1': {GetOpcode '$1'})

define(oneReg,
'$1':
   f(x: {GetOpcode '$1X'}
     y: {GetOpcode '$1Y'}
     g: {GetOpcode '$1G'}))

define(twoRegs,
'$1': f(x: f(x: {GetOpcode '$1XX'}
	     y: {GetOpcode '$1XY'}
	     g: {GetOpcode '$1XG'})
	y: f(x: {GetOpcode '$1YX'}
	     y: {GetOpcode '$1YY'}
	     g: {GetOpcode '$1YG'})
	g: f(x: {GetOpcode '$1GX'}
	     y: {GetOpcode '$1GY'}
	     g: {GetOpcode '$1GG'})))

Opcodes =
opcodes(include(OZINCDIR/instrDefs.m4))

undefine(`noReg')
undefine(`oneReg')
undefine(`twoRegs')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% The `StoreInstr' Procedure
%%

undefine(`instruction')
define(instruction,
       `ifelse($1,debugEntry,,
	       numOfRegs($2,$3,$4),1,oneReg($@),
	       numOfRegs($2,$3,$4),2,twoRegs($@),
	       noReg($@))')

define(RelBuiltinname,Builtinname)
define(FunBuiltinname,Builtinname)
define(Arity,Int)
define(NLiveRegs,Int)
define(Count,Int)
define(IsTail,Int)
define(ArityAndIsTail,Int)
define(Dummy,Int)

changequote([,])
define(arglist, [ifelse($1,1,'$2',
			$1,2,'$2'(X1),
			$1,3,'$2'(X1 X2),
			$1,4,'$2'(X1 X2 X3),
			$1,5,'$2'(X1 X2 X3 X4),
			$1,6,'$2'(X1 X2 X3 X4 X5),
			$1,7,'$2'(X1 X2 X3 X4 X5 X6),
			`errprint(too many ($1) arguments for $2
)')])

changequote(`,')


define(storeOperand,
       `ifelse($1,Label,
	       `      {StoreLabel CodeBlock X$2 LabelDict}'
,	       $1,HashTableRef,
	       `      {StoreHashTableRef CodeBlock X$2 LabelDict}'
,	       $1,,,
	       `      {Store$1 CodeBlock X$2}'
)')

define(storeOperands,
`storeOperand($2,1)dnl
storeOperand($3,2)dnl
storeOperand($4,3)dnl
storeOperand($5,4)dnl
storeOperand($6,5)dnl
storeOperand($7,6)')

define(noReg,`   [] arglist($#,$1) then
      {StoreOpcode CodeBlock Opcodes.''$1'`}
storeOperands($@)')

define(oneReg,`   [] arglist($#,$1) then
      Opcode = Opcodes.''$1'`.{Label ifelse(isReg($2),1,X1,isReg($3),1,X2,X3)}
   in
      {StoreOpcode CodeBlock Opcode}
storeOperands($@)')

define(twoRegs,`   [] arglist($#,$1) then
      Opcode = Opcodes.''$1'`.ifelse(isReg($2),0,{Label X2}.{Label X3},
				     isReg($3),0,{Label X1}.{Label X3},
				     {Label X1}.{Label X2})
   in
      {StoreOpcode CodeBlock Opcode}
storeOperands($@)')

proc {StoreInstr Instr CodeBlock LabelDict}
   case Instr of debugEntry(File Line Column Comment NLiveRegs) then
      {AddDebugInfo CodeBlock File Line}
      {StoreOpcode CodeBlock Opcodes.'debugEntry'}
      {StoreLiteral CodeBlock File}
      {StoreNumber CodeBlock Line}
      {StoreNumber CodeBlock Column}
      {StoreLiteral CodeBlock Comment}
      {StoreInt CodeBlock NLiveRegs}
include(OZINCDIR/instrDefs.m4)
   end
end
